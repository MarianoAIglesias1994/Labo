
Test_completo_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000362  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000030e  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  00000362  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000394  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000098  00000000  00000000  000003d8  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000838  00000000  00000000  00000470  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000001c3  00000000  00000000  00000ca8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000758  00000000  00000000  00000e6b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000c4  00000000  00000000  000015c4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000001f1  00000000  00000000  00001688  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000014b  00000000  00000000  00001879  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000058  00000000  00000000  000019c4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	19 c0       	rjmp	.+50     	; 0x34 <__ctors_end>
   2:	20 c0       	rjmp	.+64     	; 0x44 <__bad_interrupt>
   4:	1f c0       	rjmp	.+62     	; 0x44 <__bad_interrupt>
   6:	1e c0       	rjmp	.+60     	; 0x44 <__bad_interrupt>
   8:	1d c0       	rjmp	.+58     	; 0x44 <__bad_interrupt>
   a:	1c c0       	rjmp	.+56     	; 0x44 <__bad_interrupt>
   c:	1b c0       	rjmp	.+54     	; 0x44 <__bad_interrupt>
   e:	1a c0       	rjmp	.+52     	; 0x44 <__bad_interrupt>
  10:	19 c0       	rjmp	.+50     	; 0x44 <__bad_interrupt>
  12:	18 c0       	rjmp	.+48     	; 0x44 <__bad_interrupt>
  14:	17 c0       	rjmp	.+46     	; 0x44 <__bad_interrupt>
  16:	16 c0       	rjmp	.+44     	; 0x44 <__bad_interrupt>
  18:	15 c0       	rjmp	.+42     	; 0x44 <__bad_interrupt>
  1a:	14 c0       	rjmp	.+40     	; 0x44 <__bad_interrupt>
  1c:	13 c0       	rjmp	.+38     	; 0x44 <__bad_interrupt>
  1e:	12 c0       	rjmp	.+36     	; 0x44 <__bad_interrupt>
  20:	11 c0       	rjmp	.+34     	; 0x44 <__bad_interrupt>
  22:	10 c0       	rjmp	.+32     	; 0x44 <__bad_interrupt>
  24:	0f c0       	rjmp	.+30     	; 0x44 <__bad_interrupt>
  26:	0e c0       	rjmp	.+28     	; 0x44 <__bad_interrupt>
  28:	0d c0       	rjmp	.+26     	; 0x44 <__bad_interrupt>
  2a:	0c c0       	rjmp	.+24     	; 0x44 <__bad_interrupt>
  2c:	0b c0       	rjmp	.+22     	; 0x44 <__bad_interrupt>
  2e:	0a c0       	rjmp	.+20     	; 0x44 <__bad_interrupt>
  30:	09 c0       	rjmp	.+18     	; 0x44 <__bad_interrupt>
  32:	08 c0       	rjmp	.+16     	; 0x44 <__bad_interrupt>

00000034 <__ctors_end>:
  34:	11 24       	eor	r1, r1
  36:	1f be       	out	0x3f, r1	; 63
  38:	cf ef       	ldi	r28, 0xFF	; 255
  3a:	d4 e0       	ldi	r29, 0x04	; 4
  3c:	de bf       	out	0x3e, r29	; 62
  3e:	cd bf       	out	0x3d, r28	; 61
  40:	0d d0       	rcall	.+26     	; 0x5c <main>
  42:	63 c1       	rjmp	.+710    	; 0x30a <_exit>

00000044 <__bad_interrupt>:
  44:	dd cf       	rjmp	.-70     	; 0x0 <__vectors>
/**************************************************************
VECTORES DE INTERRUPCION
***************************************************************/

.org 0x00
rjmp main
  46:	0a c0       	rjmp	.+20     	; 0x5c <main>

rjmp ISR_INT0_INACTIVITY	
  48:	01 c0       	rjmp	.+2      	; 0x4c <ISR_INT0_INACTIVITY>
rjmp ISR_INT1_BLUETOOTH	
  4a:	04 c0       	rjmp	.+8      	; 0x54 <ISR_INT1_BLUETOOTH>

0000004c <ISR_INT0_INACTIVITY>:
/**************************************************************
RUTINA DE SERVICIO DE INTERRUPCION POR INACTIVIDAD DEL ACELEROMETRO
***************************************************************/

ISR_INT0_INACTIVITY:
CLI
  4c:	f8 94       	cli
LDI R19,1	
  4e:	31 e0       	ldi	r19, 0x01	; 1
SEI
  50:	78 94       	sei
RETI
  52:	18 95       	reti

00000054 <ISR_INT1_BLUETOOTH>:
/**************************************************************
RUTINA DE SERVICIO DE INTERRUPCION POR ACTIVACION DEL BLUETOOTH
***************************************************************/

ISR_INT1_BLUETOOTH:
CLI
  54:	f8 94       	cli
LDI R19,2	
  56:	32 e0       	ldi	r19, 0x02	; 2
SEI
  58:	78 94       	sei
RETI
  5a:	18 95       	reti

0000005c <main>:

main:


; LEDs para las pruebas (Puerto C: Rojos; Puerto D: Verdes)
LDI R20, 0b00001100			; Hay LEDs conectados a los bits seteados en dichos puertos
  5c:	4c e0       	ldi	r20, 0x0C	; 12
OUT _SFR_IO_ADDR(DDRC), R20			
  5e:	47 b9       	out	0x07, r20	; 7
LDI R20, 0b00001100			; Con un 1 quedan apagados por la logica de la placa Club de Robotica
  60:	4c e0       	ldi	r20, 0x0C	; 12
OUT _SFR_IO_ADDR(PORTC), R20	
  62:	48 b9       	out	0x08, r20	; 8

LDI R20, 0b10010000			; Hay LEDs conectados a los bits seteados en dichos puertos
  64:	40 e9       	ldi	r20, 0x90	; 144
OUT _SFR_IO_ADDR(DDRD), R20	
  66:	4a b9       	out	0x0a, r20	; 10
LDI R20, 0b10010000			; Con un 1 quedan apagados por la logica de la placa Club de Robotica
  68:	40 e9       	ldi	r20, 0x90	; 144
OUT _SFR_IO_ADDR(PORTD), R20	
  6a:	4b b9       	out	0x0b, r20	; 11

0000006c <CONFIG_BAJO_CONSUMO>:
***************************************************************/


CONFIG_BAJO_CONSUMO:
	; Config consumo de energia, PSM o PDM
	ldi R16,0b00000100	; Nibble inferior D3D2D1 = 010 es de power down mode y el lsb D0 = 1 es para activar el sleep mode
  6c:	04 e0       	ldi	r16, 0x04	; 4
	out _SFR_IO_ADDR(SMCR),R16
  6e:	03 bf       	out	0x33, r16	; 51
		
/**************************************************************
INCIALIZACION I2C, CONFIGURACION ACELEROMETRO Y RTC
***************************************************************/

RCALL config_i2cmaster_acel_rtc
  70:	c5 d0       	rcall	.+394    	; 0x1fc <config_i2cmaster_acel_rtc>

00000072 <CONFIG_INT>:
***************************************************************/
CONFIG_INT:

	;EICRA: Configura por flanco o por nivel
	;out R18, EICRA     ; Carga estado previo
	ldi R16,0b00000001	; ldi R16,0b00000001 para INT0; ldi R16,0b00000101 para INT0 e INT1 
  72:	01 e0       	ldi	r16, 0x01	; 1
	sts _SFR_IO_ADDR(EICRA), R16		;
  74:	00 93 49 00 	sts	0x0049, r16	; 0x800049 <__EEPROM_REGION_LENGTH__+0x7f0049>

	;EIMSK: Habilita las interrupciones seleccionadas
	;out R18, EIMSK     ; Carga estado previo
	ldi R16,0b00000001 	; ldi R16,0b00000001 para INT0; ldi R16,0b00000011 para INT0 e INT1 
  78:	01 e0       	ldi	r16, 0x01	; 1
	out _SFR_IO_ADDR(EIMSK),R16		;
  7a:	0d bb       	out	0x1d, r16	; 29

	;EIFR: Tiene que estar seteado junto con el bit de interrupcion global al momento de suceder la interrupcion 
	;in R18, EIFR       ; Carga estado previo
	ldi R16,0b00000001	; ldi R16,0b00000001 para INT0; ldi R16,0b00000011 para INT0 e INT1 
  7c:	01 e0       	ldi	r16, 0x01	; 1
	out _SFR_IO_ADDR(EIFR),R16		;
  7e:	0c bb       	out	0x1c, r16	; 28

SEI
  80:	78 94       	sei


; LEDs para las pruebas (Puerto C: Rojos; Puerto D: Verdes)
LDI R20, 0b00001100			; Hay LEDs conectados a los bits seteados en dichos puertos
  82:	4c e0       	ldi	r20, 0x0C	; 12
OUT _SFR_IO_ADDR(DDRC), R20			
  84:	47 b9       	out	0x07, r20	; 7
LDI R20, 0b00001100			; Con un 1 quedan apagados por la logica de la placa Club de Robotica
  86:	4c e0       	ldi	r20, 0x0C	; 12
OUT _SFR_IO_ADDR(PORTC), R20	
  88:	48 b9       	out	0x08, r20	; 8

LDI R20, 0b10010000			; Hay LEDs conectados a los bits seteados en dichos puertos
  8a:	40 e9       	ldi	r20, 0x90	; 144
OUT _SFR_IO_ADDR(DDRD), R20	
  8c:	4a b9       	out	0x0a, r20	; 10
LDI R20, 0b10010000			; Con un 1 quedan apagados por la logica de la placa Club de Robotica
  8e:	40 e9       	ldi	r20, 0x90	; 144
OUT _SFR_IO_ADDR(PORTD), R20	
  90:	4b b9       	out	0x0b, r20	; 11
BLOQUE PRINCIPAL
***************************************************************/


; Si entro al bloque principal, se prenden los LEDs del puerto D
			LDI R20, 0b00000000	
  92:	40 e0       	ldi	r20, 0x00	; 0
			OUT _SFR_IO_ADDR(PORTD), R20
  94:	4b b9       	out	0x0b, r20	; 11

00000096 <SLEEP_MODE>:

; Entra en modo sleep, al suceder una interrupcion se despierta en la instruccion siguiente
SLEEP_MODE:
			
			ldi R16,0b00000101	; lsb = 1 para activar el sleep mode
  96:	05 e0       	ldi	r16, 0x05	; 5
			out _SFR_IO_ADDR(SMCR),R16
  98:	03 bf       	out	0x33, r16	; 51
			SLEEP
  9a:	88 95       	sleep
			ldi R16,0b00000100	; lsb = 0 para desactivar el sleep mode
  9c:	04 e0       	ldi	r16, 0x04	; 4
			out _SFR_IO_ADDR(SMCR),R16
  9e:	03 bf       	out	0x33, r16	; 51

			
; En las rutinas de interrupcion se usa R19 para almacenar un registro indicador del tipo de interrupcion ocurrida
; Es una analogia del switch/case del lenguaje C
		
			CPI R19,1
  a0:	31 30       	cpi	r19, 0x01	; 1
			BREQ ALARMA
  a2:	c9 f0       	breq	.+50     	; 0xd6 <ALARMA>

000000a4 <RETORNO_ALARMA>:
RETORNO_ALARMA:
			CPI R19,2
  a4:	32 30       	cpi	r19, 0x02	; 2
			BREQ BLUETOOTH
  a6:	09 f0       	breq	.+2      	; 0xaa <BLUETOOTH>

000000a8 <RETORNO_BLUETOOTH>:
RETORNO_BLUETOOTH:
			RJMP SLEEP_MODE
  a8:	f6 cf       	rjmp	.-20     	; 0x96 <SLEEP_MODE>

000000aa <BLUETOOTH>:
/**************************************************************
RUTINA ENVIO DE ENVIO DE DATOS POR BLUETOOTH 
***************************************************************/

BLUETOOTH:	; LED Verde
LDI R21, 10	; Valor de tiempo 
  aa:	5a e0       	ldi	r21, 0x0A	; 10

000000ac <PARPADEO2>:

PARPADEO2:
		LDI R20, 0b00000000	; Prende LED
  ac:	40 e0       	ldi	r20, 0x00	; 0
		OUT _SFR_IO_ADDR(PORTD), R20	
  ae:	4b b9       	out	0x0b, r20	; 11
		RCALL RETARDO2
  b0:	08 d0       	rcall	.+16     	; 0xc2 <RETARDO2>
		LDI R20, 0b10010000		; Apaga LED
  b2:	40 e9       	ldi	r20, 0x90	; 144
		OUT _SFR_IO_ADDR(PORTD), R20	
  b4:	4b b9       	out	0x0b, r20	; 11
		RCALL RETARDO2
  b6:	05 d0       	rcall	.+10     	; 0xc2 <RETARDO2>

		DEC R21
  b8:	5a 95       	dec	r21
		CPI R21, 0
  ba:	50 30       	cpi	r21, 0x00	; 0
		BRNE PARPADEO2
  bc:	b9 f7       	brne	.-18     	; 0xac <PARPADEO2>

		LDI R19,0			; Se limpia el registro indicador
  be:	30 e0       	ldi	r19, 0x00	; 0
		RJMP RETORNO_BLUETOOTH
  c0:	f3 cf       	rjmp	.-26     	; 0xa8 <RETORNO_BLUETOOTH>

000000c2 <RETARDO2>:

RETARDO2:
		LDI R16, 10
  c2:	0a e0       	ldi	r16, 0x0A	; 10

000000c4 <LOOP12>:
LOOP12:	LDI R17, 255
  c4:	1f ef       	ldi	r17, 0xFF	; 255

000000c6 <LOOP22>:
LOOP22:	LDI R18, 255
  c6:	2f ef       	ldi	r18, 0xFF	; 255

000000c8 <LOOP32>:
LOOP32:  DEC R18
  c8:	2a 95       	dec	r18
		BRNE LOOP32			
  ca:	f1 f7       	brne	.-4      	; 0xc8 <LOOP32>
		DEC R17
  cc:	1a 95       	dec	r17
		BRNE LOOP22
  ce:	d9 f7       	brne	.-10     	; 0xc6 <LOOP22>
		DEC R16
  d0:	0a 95       	dec	r16
		BRNE LOOP12
  d2:	c1 f7       	brne	.-16     	; 0xc4 <LOOP12>
		RET
  d4:	08 95       	ret

000000d6 <ALARMA>:
/**************************************************************
RUTINA DE ALARMA
***************************************************************/

ALARMA:	; LED Rojo
LDI R21, 10	; Valor de tiempo 
  d6:	5a e0       	ldi	r21, 0x0A	; 10

000000d8 <PARPADEO>:

PARPADEO:
		LDI R20, 0b00000000	; Prende LED
  d8:	40 e0       	ldi	r20, 0x00	; 0
		OUT _SFR_IO_ADDR(PORTC), R20	
  da:	48 b9       	out	0x08, r20	; 8
		RCALL RETARDO
  dc:	08 d0       	rcall	.+16     	; 0xee <RETARDO>
		LDI R20, 0b00001100	; Apaga LED
  de:	4c e0       	ldi	r20, 0x0C	; 12
		OUT _SFR_IO_ADDR(PORTC), R20	
  e0:	48 b9       	out	0x08, r20	; 8
		RCALL RETARDO
  e2:	05 d0       	rcall	.+10     	; 0xee <RETARDO>

		DEC R21
  e4:	5a 95       	dec	r21
		CPI R21, 0
  e6:	50 30       	cpi	r21, 0x00	; 0
		BRNE PARPADEO
  e8:	b9 f7       	brne	.-18     	; 0xd8 <PARPADEO>

		LDI R19,0			; Se limpia el registro indicador
  ea:	30 e0       	ldi	r19, 0x00	; 0
		RJMP ALARMA;RETORNO_ALARMA
  ec:	f4 cf       	rjmp	.-24     	; 0xd6 <ALARMA>

000000ee <RETARDO>:

RETARDO:
		LDI R16, 10
  ee:	0a e0       	ldi	r16, 0x0A	; 10

000000f0 <LOOP1>:
LOOP1:	LDI R17, 255
  f0:	1f ef       	ldi	r17, 0xFF	; 255

000000f2 <LOOP2>:
LOOP2:	LDI R18, 255
  f2:	2f ef       	ldi	r18, 0xFF	; 255

000000f4 <LOOP3>:
LOOP3:  DEC R18
  f4:	2a 95       	dec	r18
		BRNE LOOP3			
  f6:	f1 f7       	brne	.-4      	; 0xf4 <LOOP3>
		DEC R17
  f8:	1a 95       	dec	r17
		BRNE LOOP2
  fa:	d9 f7       	brne	.-10     	; 0xf2 <LOOP2>
		DEC R16
  fc:	0a 95       	dec	r16
		BRNE LOOP1
  fe:	c1 f7       	brne	.-16     	; 0xf0 <LOOP1>
		RET
 100:	08 95       	ret

00000102 <i2c_init>:
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
	while(!(TWCR & (1<<TWINT)));    

    return TWDR;

}/* i2c_readAck */
 102:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 106:	84 e5       	ldi	r24, 0x54	; 84
 108:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__EEPROM_REGION_LENGTH__+0x7f00b8>
 10c:	08 95       	ret

0000010e <i2c_start>:
 10e:	94 ea       	ldi	r25, 0xA4	; 164
 110:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__EEPROM_REGION_LENGTH__+0x7f00bc>
 114:	ec eb       	ldi	r30, 0xBC	; 188
 116:	f0 e0       	ldi	r31, 0x00	; 0
 118:	90 81       	ld	r25, Z
 11a:	99 23       	and	r25, r25
 11c:	ec f7       	brge	.-6      	; 0x118 <i2c_start+0xa>
 11e:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 122:	98 7f       	andi	r25, 0xF8	; 248
 124:	98 30       	cpi	r25, 0x08	; 8
 126:	11 f0       	breq	.+4      	; 0x12c <i2c_start+0x1e>
 128:	90 31       	cpi	r25, 0x10	; 16
 12a:	a1 f4       	brne	.+40     	; 0x154 <i2c_start+0x46>
 12c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__EEPROM_REGION_LENGTH__+0x7f00bb>
 130:	84 e8       	ldi	r24, 0x84	; 132
 132:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__EEPROM_REGION_LENGTH__+0x7f00bc>
 136:	ec eb       	ldi	r30, 0xBC	; 188
 138:	f0 e0       	ldi	r31, 0x00	; 0
 13a:	80 81       	ld	r24, Z
 13c:	88 23       	and	r24, r24
 13e:	ec f7       	brge	.-6      	; 0x13a <i2c_start+0x2c>
 140:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 144:	98 7f       	andi	r25, 0xF8	; 248
 146:	98 31       	cpi	r25, 0x18	; 24
 148:	39 f0       	breq	.+14     	; 0x158 <i2c_start+0x4a>
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	90 34       	cpi	r25, 0x40	; 64
 14e:	29 f4       	brne	.+10     	; 0x15a <i2c_start+0x4c>
 150:	80 e0       	ldi	r24, 0x00	; 0
 152:	08 95       	ret
 154:	81 e0       	ldi	r24, 0x01	; 1
 156:	08 95       	ret
 158:	80 e0       	ldi	r24, 0x00	; 0
 15a:	08 95       	ret

0000015c <i2c_start_wait>:
 15c:	cf 93       	push	r28
 15e:	df 93       	push	r29
 160:	ec eb       	ldi	r30, 0xBC	; 188
 162:	f0 e0       	ldi	r31, 0x00	; 0
 164:	24 ea       	ldi	r18, 0xA4	; 164
 166:	a9 eb       	ldi	r26, 0xB9	; 185
 168:	b0 e0       	ldi	r27, 0x00	; 0
 16a:	cb eb       	ldi	r28, 0xBB	; 187
 16c:	d0 e0       	ldi	r29, 0x00	; 0
 16e:	34 e8       	ldi	r19, 0x84	; 132
 170:	44 e9       	ldi	r20, 0x94	; 148
 172:	20 83       	st	Z, r18
 174:	90 81       	ld	r25, Z
 176:	99 23       	and	r25, r25
 178:	ec f7       	brge	.-6      	; 0x174 <i2c_start_wait+0x18>
 17a:	9c 91       	ld	r25, X
 17c:	98 7f       	andi	r25, 0xF8	; 248
 17e:	98 30       	cpi	r25, 0x08	; 8
 180:	11 f0       	breq	.+4      	; 0x186 <i2c_start_wait+0x2a>
 182:	90 31       	cpi	r25, 0x10	; 16
 184:	b1 f7       	brne	.-20     	; 0x172 <i2c_start_wait+0x16>
 186:	88 83       	st	Y, r24
 188:	30 83       	st	Z, r19
 18a:	90 81       	ld	r25, Z
 18c:	99 23       	and	r25, r25
 18e:	ec f7       	brge	.-6      	; 0x18a <i2c_start_wait+0x2e>
 190:	9c 91       	ld	r25, X
 192:	98 7f       	andi	r25, 0xF8	; 248
 194:	90 32       	cpi	r25, 0x20	; 32
 196:	11 f0       	breq	.+4      	; 0x19c <i2c_start_wait+0x40>
 198:	98 35       	cpi	r25, 0x58	; 88
 19a:	29 f4       	brne	.+10     	; 0x1a6 <i2c_start_wait+0x4a>
 19c:	40 83       	st	Z, r20
 19e:	90 81       	ld	r25, Z
 1a0:	94 fd       	sbrc	r25, 4
 1a2:	fd cf       	rjmp	.-6      	; 0x19e <i2c_start_wait+0x42>
 1a4:	e6 cf       	rjmp	.-52     	; 0x172 <i2c_start_wait+0x16>
 1a6:	df 91       	pop	r29
 1a8:	cf 91       	pop	r28
 1aa:	08 95       	ret

000001ac <i2c_rep_start>:
 1ac:	b0 df       	rcall	.-160    	; 0x10e <i2c_start>
 1ae:	08 95       	ret

000001b0 <i2c_stop>:
 1b0:	84 e9       	ldi	r24, 0x94	; 148
 1b2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__EEPROM_REGION_LENGTH__+0x7f00bc>
 1b6:	ec eb       	ldi	r30, 0xBC	; 188
 1b8:	f0 e0       	ldi	r31, 0x00	; 0
 1ba:	80 81       	ld	r24, Z
 1bc:	84 fd       	sbrc	r24, 4
 1be:	fd cf       	rjmp	.-6      	; 0x1ba <i2c_stop+0xa>
 1c0:	08 95       	ret

000001c2 <i2c_write>:
 1c2:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__EEPROM_REGION_LENGTH__+0x7f00bb>
 1c6:	84 e8       	ldi	r24, 0x84	; 132
 1c8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__EEPROM_REGION_LENGTH__+0x7f00bc>
 1cc:	ec eb       	ldi	r30, 0xBC	; 188
 1ce:	f0 e0       	ldi	r31, 0x00	; 0
 1d0:	80 81       	ld	r24, Z
 1d2:	88 23       	and	r24, r24
 1d4:	ec f7       	brge	.-6      	; 0x1d0 <i2c_write+0xe>
 1d6:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 1da:	98 7f       	andi	r25, 0xF8	; 248
 1dc:	81 e0       	ldi	r24, 0x01	; 1
 1de:	98 32       	cpi	r25, 0x28	; 40
 1e0:	09 f4       	brne	.+2      	; 0x1e4 <i2c_write+0x22>
 1e2:	80 e0       	ldi	r24, 0x00	; 0
 1e4:	08 95       	ret

000001e6 <i2c_readNak>:
 
 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readNak(void)
{
	TWCR = (1<<TWINT) | (1<<TWEN);
 1e6:	84 e8       	ldi	r24, 0x84	; 132
 1e8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__EEPROM_REGION_LENGTH__+0x7f00bc>
	while(!(TWCR & (1<<TWINT)));
 1ec:	ec eb       	ldi	r30, 0xBC	; 188
 1ee:	f0 e0       	ldi	r31, 0x00	; 0
 1f0:	80 81       	ld	r24, Z
 1f2:	88 23       	and	r24, r24
 1f4:	ec f7       	brge	.-6      	; 0x1f0 <i2c_readNak+0xa>
	
    return TWDR;
 1f6:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__EEPROM_REGION_LENGTH__+0x7f00bb>

}/* i2c_readNak */
 1fa:	08 95       	ret

000001fc <config_i2cmaster_acel_rtc>:
	//	PORTC = 0x0C;                              // (active low LED's )

	//	DDRD  = 0x90;                              // LEDs Verdes
	//	PORTD = 0x90;                              // (active low LED's )
	
	i2c_init();                                // init I2C interface
 1fc:	82 df       	rcall	.-252    	; 0x102 <i2c_init>
	ret = i2c_start(DevADXL345+I2C_WRITE);       // set device address and write mode
 1fe:	86 ea       	ldi	r24, 0xA6	; 166
 200:	86 df       	rcall	.-244    	; 0x10e <i2c_start>
	if ( ret ) {
 202:	88 23       	and	r24, r24
 204:	11 f0       	breq	.+4      	; 0x20a <config_i2cmaster_acel_rtc+0xe>
		/* failed to issue start condition, possibly no device found */
		i2c_stop();
 206:	d4 df       	rcall	.-88     	; 0x1b0 <i2c_stop>
 208:	08 95       	ret
	//	PORTD = 0x00;                            // Prende LEDs Verdes en caso de ERROR
		}else {
		/* issuing start condition ok, device accessible */
		i2c_write(0x00);                       // Direccion del registro a leer DEVID
 20a:	80 e0       	ldi	r24, 0x00	; 0
 20c:	da df       	rcall	.-76     	; 0x1c2 <i2c_write>
		i2c_rep_start(DevADXL345+I2C_READ);       // set device address and read mode
 20e:	87 ea       	ldi	r24, 0xA7	; 167
 210:	cd df       	rcall	.-102    	; 0x1ac <i2c_rep_start>
		ret = i2c_readNak();                    // read one byte
 212:	e9 df       	rcall	.-46     	; 0x1e6 <i2c_readNak>
		i2c_stop();
 214:	cd df       	rcall	.-102    	; 0x1b0 <i2c_stop>
		
		//; Se comienza la secuencia de seteo del acelerometro en los valores necesarios
		//
		i2c_start_wait(DevADXL345+I2C_WRITE);
 216:	86 ea       	ldi	r24, 0xA6	; 166
 218:	a1 df       	rcall	.-190    	; 0x15c <i2c_start_wait>
		i2c_write(0x25);                        // ;Dato a transmitir ;THRESH_INACT  8 bit unsigned. No dejar en 0x00 umbral de inactividad (62.5 mg/LSB)
 21a:	85 e2       	ldi	r24, 0x25	; 37
 21c:	d2 df       	rcall	.-92     	; 0x1c2 <i2c_write>
		i2c_write(0x11);
 21e:	81 e1       	ldi	r24, 0x11	; 17
 220:	d0 df       	rcall	.-96     	; 0x1c2 <i2c_write>
		i2c_stop();
 222:	c6 df       	rcall	.-116    	; 0x1b0 <i2c_stop>
		
		i2c_start_wait(DevADXL345+I2C_WRITE);
 224:	86 ea       	ldi	r24, 0xA6	; 166
 226:	9a df       	rcall	.-204    	; 0x15c <i2c_start_wait>
		i2c_write(0x25);
 228:	85 e2       	ldi	r24, 0x25	; 37
 22a:	cb df       	rcall	.-106    	; 0x1c2 <i2c_write>
		i2c_rep_start(DevADXL345+I2C_READ);
 22c:	87 ea       	ldi	r24, 0xA7	; 167
 22e:	be df       	rcall	.-132    	; 0x1ac <i2c_rep_start>
		ret = i2c_readNak();
 230:	da df       	rcall	.-76     	; 0x1e6 <i2c_readNak>
		i2c_stop();
 232:	be df       	rcall	.-132    	; 0x1b0 <i2c_stop>
	//	if(ret == 0x11)
	//		PORTC &= 0x04;                       // Prende 1 LED Rojo en caso de Lectura correcta
		//
		
		//
		i2c_start_wait(DevADXL345+I2C_WRITE);
 234:	86 ea       	ldi	r24, 0xA6	; 166
 236:	92 df       	rcall	.-220    	; 0x15c <i2c_start_wait>
		i2c_write(0x26);                        // ;Dato a transmitir ;TIME_INACT  (maximo 255 segundos) (1 sec/LSB)
 238:	86 e2       	ldi	r24, 0x26	; 38
 23a:	c3 df       	rcall	.-122    	; 0x1c2 <i2c_write>
		i2c_write(0x01);
 23c:	81 e0       	ldi	r24, 0x01	; 1
 23e:	c1 df       	rcall	.-126    	; 0x1c2 <i2c_write>
		i2c_stop();
 240:	b7 df       	rcall	.-146    	; 0x1b0 <i2c_stop>
		//

		//
		i2c_start_wait(DevADXL345+I2C_WRITE);
 242:	86 ea       	ldi	r24, 0xA6	; 166
 244:	8b df       	rcall	.-234    	; 0x15c <i2c_start_wait>
		i2c_write(0x27);                        // ;Dato a transmitir ;ACT_INACT_CTL ;en 0b00001111 (D3 en 1=ac coupled)(D2D1D0 = 111 enable en los tres ejes)
 246:	87 e2       	ldi	r24, 0x27	; 39
 248:	bc df       	rcall	.-136    	; 0x1c2 <i2c_write>
		i2c_write(0x0F);
 24a:	8f e0       	ldi	r24, 0x0F	; 15
 24c:	ba df       	rcall	.-140    	; 0x1c2 <i2c_write>
		i2c_stop();
 24e:	b0 df       	rcall	.-160    	; 0x1b0 <i2c_stop>
		//
		
		//
		i2c_start_wait(DevADXL345+I2C_WRITE);
 250:	86 ea       	ldi	r24, 0xA6	; 166
 252:	84 df       	rcall	.-248    	; 0x15c <i2c_start_wait>
		i2c_write(0x2C);                        //BW_RATE;(D4=0 sin Low Power)(Rate D3D2D1D0 = 0110 : BW=3.13Hz)
 254:	8c e2       	ldi	r24, 0x2C	; 44
 256:	b5 df       	rcall	.-150    	; 0x1c2 <i2c_write>
		i2c_write(0x06);
 258:	86 e0       	ldi	r24, 0x06	; 6
 25a:	b3 df       	rcall	.-154    	; 0x1c2 <i2c_write>
		i2c_stop();
 25c:	a9 df       	rcall	.-174    	; 0x1b0 <i2c_stop>
		//

		//
		i2c_start_wait(DevADXL345+I2C_WRITE);
 25e:	86 ea       	ldi	r24, 0xA6	; 166
 260:	7d df       	rcall	.-262    	; 0x15c <i2c_start_wait>
		i2c_write(0x2F);                        //;INT_MAP	;solo la inactividad conectada al pin INT1, el resto conectadas al pin INT2
 262:	8f e2       	ldi	r24, 0x2F	; 47
 264:	ae df       	rcall	.-164    	; 0x1c2 <i2c_write>
		i2c_write(0xF7);
 266:	87 ef       	ldi	r24, 0xF7	; 247
 268:	ac df       	rcall	.-168    	; 0x1c2 <i2c_write>
		i2c_stop();
 26a:	a2 df       	rcall	.-188    	; 0x1b0 <i2c_stop>
		//

		//
		i2c_start_wait(DevADXL345+I2C_WRITE);
 26c:	86 ea       	ldi	r24, 0xA6	; 166
 26e:	76 df       	rcall	.-276    	; 0x15c <i2c_start_wait>
		i2c_write(0x2E);                        //;INT_ENABLE		;se habilita solo la interrupcion por inactividad
 270:	8e e2       	ldi	r24, 0x2E	; 46
 272:	a7 df       	rcall	.-178    	; 0x1c2 <i2c_write>
		i2c_write(0x08);
 274:	88 e0       	ldi	r24, 0x08	; 8
 276:	a5 df       	rcall	.-182    	; 0x1c2 <i2c_write>
		i2c_stop();
 278:	9b df       	rcall	.-202    	; 0x1b0 <i2c_stop>
		//

		//
		i2c_start_wait(DevADXL345+I2C_WRITE);
 27a:	86 ea       	ldi	r24, 0xA6	; 166
 27c:	6f df       	rcall	.-290    	; 0x15c <i2c_start_wait>
		i2c_write(0x2D);                        //;POWER_CTL MEASURE ON
 27e:	8d e2       	ldi	r24, 0x2D	; 45
 280:	a0 df       	rcall	.-192    	; 0x1c2 <i2c_write>
		i2c_write(0x08);						//	;se pone en 1 el bit de Measure, por defecto se prende en modo standby, no queda claro si es necesario
 282:	88 e0       	ldi	r24, 0x08	; 8
 284:	9e df       	rcall	.-196    	; 0x1c2 <i2c_write>
		i2c_stop();								//	;ponerlo en modo medicion para que anden las interrupciones
 286:	94 df       	rcall	.-216    	; 0x1b0 <i2c_stop>
		//; Fin de la secuencia de seteo del acelerometro en los valores necesarios

		//; Se comienza la secuencia de seteo del rtc en los valores necesarios

		//
		i2c_start_wait(DevDS3231+I2C_WRITE);
 288:	80 ed       	ldi	r24, 0xD0	; 208
 28a:	68 df       	rcall	.-304    	; 0x15c <i2c_start_wait>
		i2c_write(0x0E);                        // ;CONFIGURACION REGISTRO DE CONTROL
 28c:	8e e0       	ldi	r24, 0x0E	; 14
 28e:	99 df       	rcall	.-206    	; 0x1c2 <i2c_write>
		i2c_write(0x00);
 290:	80 e0       	ldi	r24, 0x00	; 0
 292:	97 df       	rcall	.-210    	; 0x1c2 <i2c_write>
		i2c_stop();
 294:	8d df       	rcall	.-230    	; 0x1b0 <i2c_stop>
		//

		//
		i2c_start_wait(DevDS3231+I2C_WRITE);
 296:	80 ed       	ldi	r24, 0xD0	; 208
 298:	61 df       	rcall	.-318    	; 0x15c <i2c_start_wait>
		i2c_write(0x00);                        // ;CONFIGURACION SEGUNDOS
 29a:	80 e0       	ldi	r24, 0x00	; 0
 29c:	92 df       	rcall	.-220    	; 0x1c2 <i2c_write>
		i2c_write(0x00);
 29e:	80 e0       	ldi	r24, 0x00	; 0
 2a0:	90 df       	rcall	.-224    	; 0x1c2 <i2c_write>
		i2c_stop();
 2a2:	86 df       	rcall	.-244    	; 0x1b0 <i2c_stop>
		//

		//
		i2c_start_wait(DevDS3231+I2C_WRITE);
 2a4:	80 ed       	ldi	r24, 0xD0	; 208
 2a6:	5a df       	rcall	.-332    	; 0x15c <i2c_start_wait>
		i2c_write(0x01);                        // ;CONFIGURACION MINUTOS
 2a8:	81 e0       	ldi	r24, 0x01	; 1
 2aa:	8b df       	rcall	.-234    	; 0x1c2 <i2c_write>
		i2c_write(0x00);						// ;0minutos
 2ac:	80 e0       	ldi	r24, 0x00	; 0
 2ae:	89 df       	rcall	.-238    	; 0x1c2 <i2c_write>
		i2c_stop();
 2b0:	7f df       	rcall	.-258    	; 0x1b0 <i2c_stop>
		//

		//
		i2c_start_wait(DevDS3231+I2C_WRITE);
 2b2:	80 ed       	ldi	r24, 0xD0	; 208
 2b4:	53 df       	rcall	.-346    	; 0x15c <i2c_start_wait>
		i2c_write(0x02);                        // ;CONFIGURACION HORA
 2b6:	82 e0       	ldi	r24, 0x02	; 2
 2b8:	84 df       	rcall	.-248    	; 0x1c2 <i2c_write>
		i2c_write(0x19);						// ;19 horas
 2ba:	89 e1       	ldi	r24, 0x19	; 25
 2bc:	82 df       	rcall	.-252    	; 0x1c2 <i2c_write>
		i2c_stop();
 2be:	78 df       	rcall	.-272    	; 0x1b0 <i2c_stop>
		//
		
		//
		i2c_start_wait(DevDS3231+I2C_WRITE);
 2c0:	80 ed       	ldi	r24, 0xD0	; 208
 2c2:	4c df       	rcall	.-360    	; 0x15c <i2c_start_wait>
		i2c_write(0x03);                        // ;CONFIGURACION DIA DE LA SEMANA
 2c4:	83 e0       	ldi	r24, 0x03	; 3
 2c6:	7d df       	rcall	.-262    	; 0x1c2 <i2c_write>
		i2c_write(0x05);						// ;dia 5 de la semana, viernes
 2c8:	85 e0       	ldi	r24, 0x05	; 5
 2ca:	7b df       	rcall	.-266    	; 0x1c2 <i2c_write>
		i2c_stop();
 2cc:	71 df       	rcall	.-286    	; 0x1b0 <i2c_stop>
		//

		//
		i2c_start_wait(DevDS3231+I2C_WRITE);
 2ce:	80 ed       	ldi	r24, 0xD0	; 208
 2d0:	45 df       	rcall	.-374    	; 0x15c <i2c_start_wait>
		i2c_write(0x04);                        // ;CONFIGURACION DIA DEL MES
 2d2:	84 e0       	ldi	r24, 0x04	; 4
 2d4:	76 df       	rcall	.-276    	; 0x1c2 <i2c_write>
		i2c_write(0x18);						// ;dia 18 del mes
 2d6:	88 e1       	ldi	r24, 0x18	; 24
 2d8:	74 df       	rcall	.-280    	; 0x1c2 <i2c_write>
		i2c_stop();
 2da:	6a df       	rcall	.-300    	; 0x1b0 <i2c_stop>
		//

		//
		i2c_start_wait(DevDS3231+I2C_WRITE);
 2dc:	80 ed       	ldi	r24, 0xD0	; 208
 2de:	3e df       	rcall	.-388    	; 0x15c <i2c_start_wait>
		i2c_write(0x05);                        // ;CONFIGURACION MES
 2e0:	85 e0       	ldi	r24, 0x05	; 5
 2e2:	6f df       	rcall	.-290    	; 0x1c2 <i2c_write>
		i2c_write(0x11);						// ;mes noviembre
 2e4:	81 e1       	ldi	r24, 0x11	; 17
 2e6:	6d df       	rcall	.-294    	; 0x1c2 <i2c_write>
		i2c_stop();
 2e8:	63 df       	rcall	.-314    	; 0x1b0 <i2c_stop>
		//

		//
		i2c_start_wait(DevDS3231+I2C_WRITE);
 2ea:	80 ed       	ldi	r24, 0xD0	; 208
 2ec:	37 df       	rcall	.-402    	; 0x15c <i2c_start_wait>
		i2c_write(0x05);                        // ;CONFIGURACION AÑO
 2ee:	85 e0       	ldi	r24, 0x05	; 5
 2f0:	68 df       	rcall	.-304    	; 0x1c2 <i2c_write>
		i2c_write(0x16);						// ;año 16
 2f2:	86 e1       	ldi	r24, 0x16	; 22
 2f4:	66 df       	rcall	.-308    	; 0x1c2 <i2c_write>
		i2c_stop();
 2f6:	5c df       	rcall	.-328    	; 0x1b0 <i2c_stop>
		//

		//; Fin de la secuencia de seteo del rtc en los valores necesarios

		//
		i2c_start_wait(DevDS3231+I2C_WRITE);
 2f8:	80 ed       	ldi	r24, 0xD0	; 208
 2fa:	30 df       	rcall	.-416    	; 0x15c <i2c_start_wait>
		i2c_write(0x05);
 2fc:	85 e0       	ldi	r24, 0x05	; 5
 2fe:	61 df       	rcall	.-318    	; 0x1c2 <i2c_write>
		i2c_rep_start(DevDS3231+I2C_READ);
 300:	81 ed       	ldi	r24, 0xD1	; 209
 302:	54 df       	rcall	.-344    	; 0x1ac <i2c_rep_start>
		ret = i2c_readNak();
 304:	70 df       	rcall	.-288    	; 0x1e6 <i2c_readNak>
		i2c_stop();
 306:	54 df       	rcall	.-344    	; 0x1b0 <i2c_stop>
 308:	08 95       	ret

0000030a <_exit>:
 30a:	f8 94       	cli

0000030c <__stop_program>:
 30c:	ff cf       	rjmp	.-2      	; 0x30c <__stop_program>
